from django.db import models
from django.contrib.auth.models import User
from django.dispatch import receiver
from django.db.models.signals import post_save, post_delete
from project.models import Project
from joltem.settings import MAIN_DIR
import logging
logger = logging.getLogger('django')

GITOLITE_ADMIN_DIRECTORY = '%sgit/gitolite/gitolite-admin/' % MAIN_DIR
GITOLITE_KEY_DIRECTORY = '%skeydir/' % GITOLITE_ADMIN_DIRECTORY
GITOLITE_CONFIG_FILE_PATH = '%sconf/gitolite.conf' % GITOLITE_ADMIN_DIRECTORY


class Repository(models.Model):
    """
    Git repository
    """
    name = models.CharField(max_length=200)
    description = models.TextField(null=True, blank=True)
    is_hidden = models.BooleanField(default=False)
    # Relations
    project = models.ForeignKey(Project)

    @property
    def full_name(self):
        """
        Full name of repository, i.e. joltem/web
        """
        return "%s/%s" % (self.project.name.lower(), self.name)


    @property
    def absolute_path(self):
        """
        Absolute path to repository
        """
        return "%sgit/repositories/%s.git" % (MAIN_DIR, self.full_name)

    class Meta:
        unique_together = ("name","project")

    def __unicode__(self):
        return self.full_name

    def save(self, force_insert=False, force_update=False, using=None, update_fields=None):
        new = False if self.pk else True
        super(Repository, self).save(force_insert, force_update, using, update_fields)
        if new:
            import subprocess
            from pygit2 import init_repository
            # Initiate bare repository on server
            init_repository(self.absolute_path, bare=True)
            # Give git group necessary permissions to repository
            subprocess.call(['chmod', '-R', 'g+rwX', self.absolute_path])
            # Add symbolic link to gitolite update hook, otherwise gitolite write permissions enforcement won't work
            subprocess.call(['ln', '-s', '%sgit/gitolite/gitolite-update' % MAIN_DIR, '%s/hooks/update' % self.absolute_path])

    def delete(self, using=None):
        super(Repository, self).delete(using)
        from shutil import rmtree
        rmtree(self.absolute_path)


GITOLITE_CONFIG_PREFIX = """
#===========================
# Administration
#===========================

repo\tgitolite-admin
\tRW\t=\tadmin

#===========================
# Repositories
#===========================

"""

@receiver([post_save, post_delete], sender=User, weak=False)
@receiver([post_save, post_delete], sender=Repository, weak=False)
def update_config(sender, **kwargs):
    """
    Update gitolite configuration file, when the user or repository sets change
    """
    logger.info("Update configuration file called : %s." % GITOLITE_CONFIG_FILE_PATH)
    with open(GITOLITE_CONFIG_FILE_PATH, 'w') as f:
        f.write("#***************************\n")
        f.write("# Generated by Joltem\n")
        f.write("#***************************\n")
        f.write(GITOLITE_CONFIG_PREFIX)
        repos = Repository.objects.all()
        for repo in repos:
            # Repository permissions
            f.write("repo\t%s\n" % repo.full_name)
            f.write("\tRW\t=\t@all\n")
            # Personal branches
            # http://gitolite.com/gitolite/special.html
            f.write("\tRW\tu/USER/\t=\t@all\n")  # TODO move this into update hook
            # VREF for solution branch permission
            for user in User.objects.all():
                f.write("\t-\tVREF/UPDATE/%s/%d\t=\t%s\n" % (user.username, repo.id, user.username))
        logger.info("Update configuration file called : %s." % GITOLITE_CONFIG_FILE_PATH)
    logger.info("Add configuration file.")
    git_command("add -v %s" % GITOLITE_CONFIG_FILE_PATH)
    logger.info("Commit configuration file changes.")
    git_command("commit -vm 'Configuration changes.'")
    logger.info("Push configuration file changes.")
    git_command("push -v origin master")


class Authentication(models.Model):
    """
    A public authentication key for SSH
    """
    name = models.CharField(max_length=200)
    key = models.TextField()
    # Relations
    user = models.ForeignKey(User)

    def __unicode__(self):
        return self.name

    @property
    def file_path(self):
        file_path = "%s%s@%s.pub" % (GITOLITE_KEY_DIRECTORY, self.user.username, self.id)
        logger.info("Get file key path : %s" % file_path)
        return file_path

@receiver(post_save, sender=Authentication, weak=False)
def add_key(sender, **kwargs):
    """
    Add key to directory
    """
    import os
    if not os.path.exists(GITOLITE_KEY_DIRECTORY):
        os.makedirs(GITOLITE_KEY_DIRECTORY)
    key = kwargs.get('instance')
    logger.info("Add key called, instance %s" % key)
    file_path = key.file_path
    with open(file_path, 'w') as f:
        f.write(key.key)
    git_command("add %s" % file_path)
    commit_push()

@receiver(post_delete, sender=Authentication, weak=False)
def remove_key(sender, **kwargs):
    """
    Remove key from directory
    """
    key = kwargs.get('instance')
    logger.info("Remove key called, instance %s" % key)
    from os import remove
    try:
        file_path = key.file_path
        remove(file_path)
        git_command("rm %s" % file_path)
    except OSError, e:
        logger.error(e)
    commit_push()


# Git utility functions

def git_command(command):
    if command:
        from subprocess import call
        call("git --git-dir={0}.git --work-tree={0} {1}".format(GITOLITE_ADMIN_DIRECTORY, command), shell=True)


def commit_push():
    """
    Commit and push changes
    """
    logger.info("Commit & push")
    git_command("commit -v -am 'Keys changes.'")
    git_command("push -v origin master")
